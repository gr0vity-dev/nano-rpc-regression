PARAMETERS = {
    'optional': {
        'account': [],
        'account_filter': [[
            "nano_3itphg56oasr3wudiny99xfd38yfxyxm6hsfxuedos3a3m74gxmn4njzx5np",
            "nano_1gyeqc6u5j3oaxbe5qy1hyz3q745a318kh8h9ocnpan7fuxnq85cxqboapu5"
        ]],
        'accounts':
        [[
            "nano_3itphg56oasr3wudiny99xfd38yfxyxm6hsfxuedos3a3m74gxmn4njzx5np",
            "nano_1gyeqc6u5j3oaxbe5qy1hyz3q745a318kh8h9ocnpan7fuxnq85cxqboapu5",
            "nano_1ge7edbt774uw7z8exomwiu19rd14io1nocyin5jwpiit3133p9eaaxn74ub",
            "nano_1ge7edbt774uw7z8exomwiu19rd14io1nocyin5jwpiit3133p9eaaxn74uc"
        ],
         [
             "nano_3itphg56oasr3wudiny99xfd38yfxyxm6hsfxuedos3a3m74gxmn4njzx5np",
             "nano_87624823gfhjgdsXVGH"
         ]],
        'announcements': [],
        'async': [],
        'block': [],
        'bypass_frontier_confirmation': [],
        'contents': [],
        'count': ["2"],
        'destinations': [],
        'difficulty': [],
        'force': ["true", "false"],
        'hash':
        ["AE393CAA100411D13EB672B932D986F1DBEAC1515F667946C3BB8E31C98554F8"],
        'head':
        ["nano_3itphg56oasr3wudiny99xfd38yfxyxm6hsfxuedos3a3m74gxmn4njzx5np"],
        'id': ["id1"],
        'include_active': ["true", "false"],
        'include_cemented': ["true", "false"],
        'include_confirmed': ["true", "false"],
        'include_not_found': ["true", "false"],
        'include_only_confirmed': ["true", "false"],
        'include_trend': ["true", "false"],
        'index': ["100"],
        'json_block': ["true", "false"],
        'min_version': ["true", "false"],
        'modified_since': ["1511476234"],
        'multiplier': ["2"],
        'offset': ["1", "10"],
        'peer_details': ["true", "false"],
        'pending': ["true", "false"],
        'raw': ["true", "false"],
        'receivable': ["true", "false"],
        'receive_hash': ["true", "false"],
        'representative': ["true", "false"],
        'representatives': ["true", "false"],
        'reverse': ["true", "false"],
        'sorting': ["true", "false"],
        'source': ["true", "false"],
        'sources': ["true", "false"],
        'start':
        ["nano_3itphg56oasr3wudiny99xfd38yfxyxm6hsfxuedos3a3m74gxmn4njzx5np"],
        'subtype': ["send", "receive"],
        'threads': ["2"],
        'threshold': ["500000000000000000000000000000000000"],
        'use_peers': ["true", "false"],
        'version': ["work_2"],
        'watch_work': ["true", "false"],
        'work': []
    },
    'required': {
        'account': [
            "nano_3itphg56oasr3wudiny99xfd38yfxyxm6hsfxuedos3a3m74gxmn4njzx5np",
            "nano_1gyeqc6u5j3oaxbe5qy1hyz3q745a318kh8h9ocnpan7fuxnq85cxqboapu5",
            "nano_1ge7edbt774uw7z8exomwiu19rd14io1nocyin5jwpiit3133p9eaaxn74ub",
            "nano_1ge7edbt774uw7z8exomwiu19rd14io1nocyin5jwpiit3133p9eaaxn74uc"
        ],
        'accounts': [
            [
                "nano_3itphg56oasr3wudiny99xfd38yfxyxm6hsfxuedos3a3m74gxmn4njzx5np",
                "nano_1gyeqc6u5j3oaxbe5qy1hyz3q745a318kh8h9ocnpan7fuxnq85cxqboapu5",
                "nano_1ge7edbt774uw7z8exomwiu19rd14io1nocyin5jwpiit3133p9eaaxn74ub",
                "nano_1ge7edbt774uw7z8exomwiu19rd14io1nocyin5jwpiit3133p9eaaxn74uc"
            ],
            [
                "nano_3itphg56oasr3wudiny99xfd38yfxyxm6hsfxuedos3a3m74gxmn4njzx5np",
                "nano_87624823gfhjgdsXVGH"
            ],
            [
                "nano_3itphg56oasr3wudiny99xfd38yfxyxm6hsfxuedos3a3m74gxmn4njzx5np",
                "nano_1ge7edbt774uw7z8exomwiu19rd14io1nocyin5jwpiit3133p9eaaxn74ub"
            ]
        ],
        'address': [
            "::ffff:192.169.0.1",
        ],
        'amount': ["1"],
        'balance': ["199000000000000000000000000000000000000"],
        'block': [
            '{"type": "state","account": "nano_1ge7edbt774uw7z8exomwiu19rd14io1nocyin5jwpiit3133p9eaaxn74ub","previous": "CE7E7AB0BC9F3D585C3E58E28ED285388B8174A221D1F890489E22768041CBAC","representative": "nano_1ge7edbt774uw7z8exomwiu19rd14io1nocyin5jwpiit3133p9eaaxn74ub","balance": "199000000000000000000000000000000000000","link": "C3567B864AA3380F36B853C73F5AB09BCDEFBB323F2DEED8BAE4280CCA277674","link_as_account": "nano_3itphg56oasr3wudiny99xfd38yfxyxm6hsfxuedos3a3m74gxmn4njzx5np","signature": "198B8E75A4E937E7DD9AF9A303FA1AE729D34566DD384456ADFC067F05B681B99A58DB1B6B0A0445AA155B98D4BD2921881D8EB53795A3ED629463FB7DADF50B","work": "6602d6f343de01f3"}'
        ],
        'count': ["1"],
        'destination':
        ["nano_3itphg56oasr3wudiny99xfd38yfxyxm6hsfxuedos3a3m74gxmn4njzx5np"],
        'epoch': ["2"],
        'hash': [
            "AE393CAA100411D13EB672B932D986F1DBEAC1515F667946C3BB8E31C98554F8",
            "AE393CAA100411D13EB672B932D986F1DBEAC1515F667946C3BB8E31C98554F9",
            "SOME_BAD_HASH"
        ],
        'hashes':
        [["AE393CAA100411D13EB672B932D986F1DBEAC1515F667946C3BB8E31C98554F8"],
         ["SINGLE_BAD_HASH"],
         [
             "AE393CAA100411D13EB672B932D986F1DBEAC1515F667946C3BB8E31C98554F8",
             "CE7E7AB0BC9F3D585C3E58E28ED285388B8174A221D1F890489E22768041CBAC"
         ],
         [
             "AE393CAA100411D13EB672B932D986F1DBEAC1515F667946C3BB8E31C98554F8",
             "CE7E7AB0BC9F3D585C3E58E28ED285388B8174A221D1F890489E22768041CBAD"
         ],
         [
             "AE393CAA100411D13EB672B932D986F1DBEAC1515F667946C3BB8E31C98554F8",
             "BAD_HASH_AS_PART_OF_LIST"
         ]],
        'index': [],
        'json_block': ["true", "false"],
        'key': [
            "0000000000000000000000000000000000000000000000000000000000000000",
            "546DB5A6A45774BD849CD4289D5D89224C927B072D9825FBC86B208D69F6175D",
            "546DB5A6A45774BD849CD4289D5D89224C927B072D9825FBC86B208D69F6175A"
        ],
        'link':
        ["C3567B864AA3380F36B853C73F5AB09BCDEFBB323F2DEED8BAE4280CCA277674"],
        'min_read_time': ["1000"],
        'min_write_time': ["0"],
        'password': ["strong_password"],
        'port': ["45101"],
        'previous':
        ["CE7E7AB0BC9F3D585C3E58E28ED285388B8174A221D1F890489E22768041CBAC"],
        'representative':
        ["nano_1ge7edbt774uw7z8exomwiu19rd14io1nocyin5jwpiit3133p9eaaxn74ub"],
        'root': [
            "EE125B1B1D85D3C24636B3590E1642D9F21B166C0C6CD99C9C6087A1224A0C44EE125B1B1D85D3C24636B3590E1642D9F21B166C0C6CD99C9C6087A1224A0C44"
        ],
        'seed':
        ["0000000000000000000000000000000000000000000000000000000000001234"],
        'source':
        ["5A182DBB9409EF100DA0B6DFF78321C67179EEFA9069F3B562DA67D8C77F7F9C"],
        'type': ["state", "counters", "samples", "objects"],
        'wallet':
        ["5A182DBB9409EF100DA0B6DFF78321C67179EEFA9069F3B562DA67D8C77F7F9C"],
        'work': ["6602d6f343de01f3"]
    }
}

import argparse
import collections
import json
from itertools import combinations, product
from nanorpc.client import NanoRpc, NodeVersion
import asyncio


class Executor:

    def __init__(self, nano_rpc):
        self.nano_rpc = nano_rpc
        self.results = {}

    async def execute_and_store(self,
                                command,
                                required_args,
                                optional_args,
                                max_concurrent_tasks=1):
        semaphore = asyncio.Semaphore(max_concurrent_tasks)
        tasks = [
            self._execute_command_with_semaphore(command, req_args, opt_args,
                                                 semaphore)
            for req_args in product(*required_args)
            for opt_args in self._generate_opt_args(optional_args)
        ]
        await asyncio.gather(*tasks)

    async def _execute_command_with_semaphore(self, command, required_args,
                                              optional_args, semaphore):
        async with semaphore:
            await self._execute_command(command, required_args, optional_args)

    async def _execute_command(self, command, req_args, opt_args):
        method = getattr(self.nano_rpc, command)
        key = self._generate_key(command, req_args, opt_args)
        try:
            self.results[key] = await method(*req_args, **opt_args)
        except Exception as e:
            self.results[key] = str(e)

    @staticmethod
    def _generate_key(command, req_args, opt_args):

        def format_arg(arg):
            if isinstance(arg, list):
                return '|'.join(sorted(map(str, arg)))
            return str(arg)

        formatted_req_args = '|'.join(
            sorted(format_arg(arg) for arg in req_args))
        formatted_opt_args = '|'.join(f'{k}={format_arg(v)}'
                                      for k, v in sorted(opt_args.items()))
        return f"{command}|{formatted_req_args}|{formatted_opt_args}"

    @staticmethod
    def _generate_opt_args(optional_args):
        for r in range(len(optional_args) + 1):
            for opt_combination in combinations(optional_args, r):
                for opt_args in product(*(PARAMETERS["optional"].get(arg, [])
                                          for arg in opt_combination)):
                    yield dict(zip(opt_combination, opt_args))


def extract_args(info):
    required_args = [
        PARAMETERS["required"].get(arg, []) for arg in info["required"]
    ]
    optional_args = info["optional"]
    return required_args, optional_args


def filter_commands(commands):
    filter_out = ["stop"]
    for command in filter_out:
        commands.pop(command)
        print(f"'{command}' command has been filtered from execution")


async def execute_all(nano_rpc_url, rpc_node_version):
    nano_rpc = NanoRpc(nano_rpc_url, NodeVersion[rpc_node_version])
    executor = Executor(nano_rpc)

    node_version = await nano_rpc.version()

    print(
        f"Running rpc version {rpc_node_version} on node {node_version['node_vendor']}"
    )

    commands = nano_rpc.commands
    filter_commands(commands)
    for command, info in commands.items():
        required_args, optional_args = extract_args(info)
        await executor.execute_and_store(command, required_args, optional_args)

    return executor.results


def write_results_to_file(results, filename):
    sorted_results = collections.OrderedDict(sorted(results.items()))

    # Extract the version
    version_string = sorted_results.get('version||', {}).get(
        'node_vendor', 'V')  # Default to 'V' if version is not available
    version_number = version_string.split(' ')[-1].replace('.', '-')

    # Format the filename
    filename = f'results_{len(sorted_results)}_{version_number}_{filename}.json'

    with open(filename, 'w') as f:
        json.dump(sorted_results, f, indent=4)
    print(filename)


def format_version(version):
    formatted_version = version.replace('.', '_').upper()
    return formatted_version if formatted_version.startswith(
        'V') else 'V' + formatted_version


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="NanoRpc executor script.")
    parser.add_argument("-url", "--url", help="NanoRpc URL.")
    parser.add_argument("-v", "--version", help="Node version.")
    parser.add_argument("-f", "--file", help="Filename to save results.")
    args = parser.parse_args()

    formatted_version = format_version(args.version)
    results = asyncio.run(execute_all(args.url, formatted_version))
    write_results_to_file(results, args.file)
